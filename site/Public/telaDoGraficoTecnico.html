<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="./css/headerTeste.css"">
      <!-- Linkando O  CSS da tela de dashboard (grafico)-->      
      <!-- linkando os icones-->
      <link rel=" stylesheet" href="https://unicons.iconscout.com/release/v4.0.0/css/line.css">
  <link rel="stylesheet" href="./css/telaDeGraficoTecnico.css">
  <!-- linkando os icones-->
  <link rel="stylesheet" href="https://unicons.iconscout.com/release/v4.0.0/css/line.css">

  <!-- Linkando o chat js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <script src="../dist/gauge.min.js"></script>
  <link rel="stylesheet" href="./css/modal.css  ">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

  <title>Document</title>
</head>
;

<body>
  <!-- Header lateral -->
  <div id="header" class="header">
  </div>
  <!-- Header Superior -->
  <div class="headerTopzaum">
    <div class="menu" onclick="menu()">
      <i class="uil uil-list-ul"></i>
    </div>

    <div class="logo" onclick="disco()">
      <img src="./assets/img/Monitoring Solution (500 × 250 px).svg" alt="">
    </div>
    <div class="ladinho">
      <button class="reiniciar" onclick="GerarPDF3()">
        Gerar PDF
      </button>
      <button onclick="openModal()" class="reiniciar">
        Paremetrizar
      </button>
    </div>
  </div>
  <!--Graficos-->
  <div class="containerGrafico">
    <div class="containerLadoEsquerdo">
      <div class="grafico">
        <span class="Titulo">
          Quantidade de reinicializações
        </span>
        <canvas id="myChart">
        </canvas>
      </div>
    </div>
    <div class="containerLadoDireito">
      <div class="containerParteDeCima">
        <div class="containerLadoEsquerdo">
          <div class="card">
            <span class="titulo">CPU</span>
            <canvas id='gauge-cpu' class="gauge"></canvas>
            <span class="TituloGauge"><span class="red" id="tituloCPU">0%</span> / 100% </span>
          </div>
        </div>
        <div class="containerLadoDireito">
          <div class="card">
            <span class="titulo">Seu totem está ligado a</span>

            <span class="TituloGauge" id="tituloVidaUtil">0 dias 0 horas e 0minutos</span>

          </div>
        </div>


        <div id="headerTopzinho" style="display: none;">

        </div>
      </div>
      <div class="containerParteDeBaixo">
        <div class="card">
          <div class="botaos">
            <div class="botao">
              <button onclick="openModal3()">
                Verificar Chamados
              </button>
            </div>
            <div class="botao">
              <button onclick="openModal2()">Registrar incidente</button>
            </div>
            <div class="chamados">
              <span id="chamadosAberto">0 Chamados em aberto</span>
            </div>
          </div>
        </div>
        <div class="containerLadoEsquerdo">
          <div class="card">
            <span class="titulo">RAM</span>
            <canvas id='gauge-ram' class="gauge"></canvas>
            <span class="TituloGauge"><span id="tituloRam" class="yellow">0%</span> / 100%</span>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- **************************************************************************************** -->

  <!--Menu Incidente -->

  <div id="my-modal2" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-direita">
          <h2>Registrar Incidente</h2>
        </div>
        <div>
          <img src="./assets/img/Monitoring_Solution.svg" width="50px" height="50px" alt="">
        </div>
        <div class="modal-esquerda">
          <span class="close" onclick="closeModal2()">&times;</span>
        </div>
      </div>
      <div class="modal-body">

        <div class="containerInput">
          <input class="input margin" type="text" placeholder="Titulo" id="inputTitulo">
        </div>
        <div class="containerInputC">
          Descrição:
        </div>
        <div class="containerInput">
          <textarea class="input margin" type="number" id="inputDescricao"></textarea>
          <div>
            <input class="" type="date" id="inputData">
          </div>
        </div>
        <div class="botao">
          <button onclick="cadastrarOcorrencia()">Cadastrar informações</button>
        </div>
      </div>
      <div class="modal-footer">
        <h3>Inifinity Solutions</h3>
      </div>
    </div>
  </div>


  <!--Menu-->

  <div id="my-modal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-direita">
          <h2>Parametrizar</h2>
        </div>
        <div>
          <img src="./assets/img/Monitoring_Solution.svg" width="50px" height="50px" alt="">
        </div>
        <div class="modal-esquerda">
          <span class="close" onclick="closeModal()">&times;</span>
        </div>
      </div>
      <div class="modal-body">
        <div class="containerInput">
          RAM:
        </div>
        <div class="containerInput">
          <input class="input margin" type="number" placeholder="Acima de % para entrar em atenção" id="inputAtencaoRam"
            onkeyup="validarInputCPU()">
          <input class="input margin" type="number" placeholder="Acima de % para entrar em critico" id="inputCriticoRam"
            onkeyup="validarInputCPU()">
        </div>
        <div class="containerInputC">
          CPU:
        </div>
        <div class="containerInput">
          <input class="input margin" type="number" placeholder="Acima de % para entrar em atenção" max="100"
            id="inputAtencaoCPU" onkeyup="validarInputCPU()">
          <input class="input margin" type="number" placeholder="Acima de % para entrar em critico" max="100"
            id="inputCriticoCPU" onkeyup="validarInputCPU()">
        </div>
        <div class="containerInputC">
          Aviso: Uso critico do totem
        </div>
        <div class="containerInput aviso">
          <p>
            Quando o uso do hardware atingir o estado crítico, o totem iniciará um processo de auto reinicialização em
            10 minutos. Se o uso crítico persistir durante esse tempo, o totem será reiniciado para evitar danos futuros
            no hardware.
          </p>
        </div>
        <div class="botao">
          <button onclick="cadastrarParametrizacao()">Cadastrar informações</button>
        </div>
      </div>
      <div class="modal-footer">
        <h3>Inifinity Solutions</h3>
      </div>
    </div>
  </div>


  <div id="my-modal3" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <div class="modal-direita">
          <h2>Chamados</h2>
        </div>
        <div>
          <img src="./assets/img/Monitoring_Solution.svg" width="50px" height="50px" alt="">
        </div>
        <div class="modal-esquerda">
          <span class="close" onclick="closeModal3()">&times;</span>
        </div>
      </div>
      <div class="modal-body" id="bodyModal">




      </div>
      <div class="modal-footer">
        <h3>Inifinity Solutions</h3>
      </div>
    </div>
    <div id="element">

    </div>
</body>


</html>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.9.2/html2pdf.bundle.js"></script>


<script src="./js/headerOficial.js">
</script>
<script>
  const inputAtencaoRam = document.getElementById('inputAtencaoRam');
  const inputCriticoRam = document.getElementById('inputCriticoRam');
  const inputAtencaoCPU = document.getElementById('inputAtencaoCPU');
  const inputCriticoCPU = document.getElementById('inputCriticoCPU');

  // Adiciona evento de mudança às inputs de RAM
  inputAtencaoRam.addEventListener('change', validarInputRam);
  inputCriticoRam.addEventListener('change', validarInputRam);

  // Adiciona evento de mudança às inputs de CPU
  inputAtencaoCPU.addEventListener('change', validarInputCPU);
  inputCriticoCPU.addEventListener('change', validarInputCPU);

  function validarInputRam() {
    const valorAtencao = parseInt(inputAtencaoRam.value);
    const valorCritico = parseInt(inputCriticoRam.value);

    if (valorAtencao < valorCritico) {
      inputAtencaoRam.value = Math.min(valorAtencao, valorCritico);
    }

    if (valorAtencao > 100) {
      inputAtencaoRam.value = 100;
    }

    if (valorCritico > 100) {
      inputCriticoRam.value = 100;
    }
  }

  function validarInputCPU() {
    const valorAtencao = parseInt(inputAtencaoCPU.value);
    const valorCritico = parseInt(inputCriticoCPU.value);

    if (valorAtencao < valorCritico) {
      inputAtencaoCPU.value = Math.min(valorAtencao, valorCritico);
    }

    if (valorAtencao > 100) {
      inputAtencaoCPU.value = 100;
    }

    if (valorCritico > 100) {
      inputCriticoCPU.value = 100;
    }
  }

  let maximoCPU = 10000;
  let maximoRAM = 10000;
  let zonaAmarelaRAM = 4000;
  let zonaAmarelaCPU = 4000;
  let zonaVermelhaRAM = 7000;
  let zonaVermelhaCPU = 7000;
  let zonaVerdeRAM = zonaVermelhaRAM - zonaAmarelaCPU;
  let zonaVerdeCPU = zonaVermelhaCPU - zonaAmarelaCPU;
  let primeiru = 1;
  function cadastrarParametrizacao() {

    fetch(`/medidas/editarParametro/${idFilial}/${numeroDeIdentificacao}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        atencaoRam: inputAtencaoRam.value,
        criticoRam: inputCriticoRam.value,
        atencaoCpu: inputAtencaoCPU.value,
        criticoCpu: inputCriticoCPU.value,
        primeiro: primeiru
      })
    }).then(function (resposta) {

      if (resposta.ok) {
        if (primeiru == 1) {
          primeiru++;
          cadastrarParametrizacao();
        } else {
          window.location = "./telaDoGraficoTecnico.html"
        }
      } else if (resposta.status == 404) {
        window.alert("Deu 404!");
      } else {
        throw ("Houve um erro ao tentar realizar a postagem! Código da resposta: " + resposta.status);
      }
    }).catch(function (resposta) {
      console.log(`#ERRO: ${resposta}`);
    });
    closeModal();


  }



  const ctx = document.getElementById('myChart');
  chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31'],
      datasets: []
    },
    options: {
      scales: {
        y: {
          beginAtZero: true
        }
      }
    }
  });

</script>
<script src="./js/modal.js">

</script>
<script>
  (function () { function t(t, i) { for (var e in i) m.call(i, e) && (t[e] = i[e]); function s() { this.constructor = t } return s.prototype = i.prototype, t.prototype = new s, t.__super__ = i.prototype, t } var i, e, s, n, o, p, a, h, r, l, g, c, u, d = [].slice, m = {}.hasOwnProperty, x = [].indexOf || function (t) { for (var i = 0, e = this.length; i < e; i++)if (i in this && this[i] === t) return i; return -1 }; function f(t, i) { null == t && (t = !0), this.clear = null == i || i, t && AnimationUpdater.add(this) } function v() { return v.__super__.constructor.apply(this, arguments) } function y(t, i) { this.el = t, this.fractionDigits = i } function V(t, i) { if (this.elem = t, this.text = null != i && i, V.__super__.constructor.call(this), void 0 === this.elem) throw new Error("The element isn't defined."); this.value = 1 * this.elem.innerHTML, this.text && (this.value = 0) } function w(t) { if (this.gauge = t, void 0 === this.gauge) throw new Error("The element isn't defined."); this.ctx = this.gauge.ctx, this.canvas = this.gauge.canvas, w.__super__.constructor.call(this, !1, !1), this.setOptions() } function S(t) { this.elem = t } function M(t) { var i, e; this.canvas = t, M.__super__.constructor.call(this), this.percentColors = null, "undefined" != typeof G_vmlCanvasManager && (this.canvas = window.G_vmlCanvasManager.initElement(this.canvas)), this.ctx = this.canvas.getContext("2d"), i = this.canvas.clientHeight, e = this.canvas.clientWidth, this.canvas.height = i, this.canvas.width = e, this.gp = [new p(this)], this.setOptions() } function C(t) { this.canvas = t, C.__super__.constructor.call(this), "undefined" != typeof G_vmlCanvasManager && (this.canvas = window.G_vmlCanvasManager.initElement(this.canvas)), this.ctx = this.canvas.getContext("2d"), this.setOptions(), this.render() } function _() { return _.__super__.constructor.apply(this, arguments) } !function () { var s, n, t, o, i, e, a; for (t = 0, i = (a = ["ms", "moz", "webkit", "o"]).length; t < i && (e = a[t], !window.requestAnimationFrame); t++)window.requestAnimationFrame = window[e + "RequestAnimationFrame"], window.cancelAnimationFrame = window[e + "CancelAnimationFrame"] || window[e + "CancelRequestAnimationFrame"]; s = null, o = 0, n = {}, requestAnimationFrame ? window.cancelAnimationFrame || (s = window.requestAnimationFrame, window.requestAnimationFrame = function (t, i) { var e; return e = ++o, s(function () { if (!n[e]) return t() }, i), e }, window.cancelAnimationFrame = function (t) { return n[t] = !0 }) : (window.requestAnimationFrame = function (t, i) { var e, s, n, o; return e = (new Date).getTime(), o = Math.max(0, 16 - (e - n)), s = window.setTimeout(function () { return t(e + o) }, o), n = e + o, s }, window.cancelAnimationFrame = function (t) { return clearTimeout(t) }) }(), u = function (t) { var i, e; for (t -= 3600 * (i = Math.floor(t / 3600)) + 60 * (e = Math.floor((t - 3600 * i) / 60)), t += "", e += ""; e.length < 2;)e = "0" + e; for (; t.length < 2;)t = "0" + t; return (i = i ? i + ":" : "") + e + ":" + t }, g = function () { var t, i, e; return e = (i = 1 <= arguments.length ? d.call(arguments, 0) : [])[0], t = i[1], r(e.toFixed(t)) }, c = function (t, i) { var e, s, n; for (e in s = {}, t) m.call(t, e) && (n = t[e], s[e] = n); for (e in i) m.call(i, e) && (n = i[e], s[e] = n); return s }, r = function (t) { var i, e, s, n; for (s = (e = (t += "").split("."))[0], n = "", 1 < e.length && (n = "." + e[1]), i = /(\d+)(\d{3})/; i.test(s);)s = s.replace(i, "$1,$2"); return s + n }, l = function (t) { return "#" === t.charAt(0) ? t.substring(1, 7) : t }, f.prototype.animationSpeed = 32, f.prototype.update = function (t) { var i; return null == t && (t = !1), !(!t && this.displayedValue === this.value || (this.ctx && this.clear && this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), i = this.value - this.displayedValue, Math.abs(i / this.animationSpeed) <= .001 ? this.displayedValue = this.value : this.displayedValue = this.displayedValue + i / this.animationSpeed, this.render(), 0)) }, t(v, h = f), v.prototype.displayScale = 1, v.prototype.forceUpdate = !0, v.prototype.setTextField = function (t, i) { return this.textField = t instanceof a ? t : new a(t, i) }, v.prototype.setMinValue = function (t, i) { var e, s, n, o, a; if (this.minValue = t, null == i && (i = !0), i) { for (this.displayedValue = this.minValue, a = [], s = 0, n = (o = this.gp || []).length; s < n; s++)e = o[s], a.push(e.displayedValue = this.minValue); return a } }, v.prototype.setOptions = function (t) { return null == t && (t = null), this.options = c(this.options, t), this.textField && (this.textField.el.style.fontSize = t.fontSize + "px"), .5 < this.options.angle && (this.options.angle = .5), this.configDisplayScale(), this }, v.prototype.configDisplayScale = function () { var t, i, e, s, n; return s = this.displayScale, !1 === this.options.highDpiSupport ? delete this.displayScale : (i = window.devicePixelRatio || 1, t = this.ctx.webkitBackingStorePixelRatio || this.ctx.mozBackingStorePixelRatio || this.ctx.msBackingStorePixelRatio || this.ctx.oBackingStorePixelRatio || this.ctx.backingStorePixelRatio || 1, this.displayScale = i / t), this.displayScale !== s && (n = this.canvas.G__width || this.canvas.width, e = this.canvas.G__height || this.canvas.height, this.canvas.width = n * this.displayScale, this.canvas.height = e * this.displayScale, this.canvas.style.width = n + "px", this.canvas.style.height = e + "px", this.canvas.G__width = n, this.canvas.G__height = e), this }, v.prototype.parseValue = function (t) { return t = parseFloat(t) || Number(t), isFinite(t) ? t : 0 }, s = v, y.prototype.render = function (t) { return this.el.innerHTML = g(t.displayedValue, this.fractionDigits) }, a = y, t(V, h), V.prototype.displayedValue = 0, V.prototype.value = 0, V.prototype.setVal = function (t) { return this.value = 1 * t }, V.prototype.render = function () { var t; return t = this.text ? u(this.displayedValue.toFixed(0)) : r(g(this.displayedValue)), this.elem.innerHTML = t }, i = V, t(w, h), w.prototype.displayedValue = 0, w.prototype.value = 0, w.prototype.options = { strokeWidth: .035, length: .1, color: "#000000", iconPath: null, iconScale: 1, iconAngle: 0 }, w.prototype.img = null, w.prototype.setOptions = function (t) { if (null == t && (t = null), this.options = c(this.options, t), this.length = 2 * this.gauge.radius * this.gauge.options.radiusScale * this.options.length, this.strokeWidth = this.canvas.height * this.options.strokeWidth, this.maxValue = this.gauge.maxValue, this.minValue = this.gauge.minValue, this.animationSpeed = this.gauge.animationSpeed, this.options.angle = this.gauge.options.angle, this.options.iconPath) return this.img = new Image, this.img.src = this.options.iconPath }, w.prototype.render = function () { var t, i, e, s, n, o, a, h, r; if (t = this.gauge.getAngle.call(this, this.displayedValue), h = Math.round(this.length * Math.cos(t)), r = Math.round(this.length * Math.sin(t)), o = Math.round(this.strokeWidth * Math.cos(t - Math.PI / 2)), a = Math.round(this.strokeWidth * Math.sin(t - Math.PI / 2)), i = Math.round(this.strokeWidth * Math.cos(t + Math.PI / 2)), e = Math.round(this.strokeWidth * Math.sin(t + Math.PI / 2)), this.ctx.beginPath(), this.ctx.fillStyle = this.options.color, this.ctx.arc(0, 0, this.strokeWidth, 0, 2 * Math.PI, !1), this.ctx.fill(), this.ctx.beginPath(), this.ctx.moveTo(o, a), this.ctx.lineTo(h, r), this.ctx.lineTo(i, e), this.ctx.fill(), this.img) return s = Math.round(this.img.width * this.options.iconScale), n = Math.round(this.img.height * this.options.iconScale), this.ctx.save(), this.ctx.translate(h, r), this.ctx.rotate(t + Math.PI / 180 * (90 + this.options.iconAngle)), this.ctx.drawImage(this.img, -s / 2, -n / 2, s, n), this.ctx.restore() }, p = w, S.prototype.updateValues = function (t) { return this.value = t[0], this.maxValue = t[1], this.avgValue = t[2], this.render() }, S.prototype.render = function () { var t, i; return this.textField && this.textField.text(g(this.value)), 0 === this.maxValue && (this.maxValue = 2 * this.avgValue), i = this.value / this.maxValue * 100, t = this.avgValue / this.maxValue * 100, $(".bar-value", this.elem).css({ width: i + "%" }), $(".typical-value", this.elem).css({ width: t + "%" }) }, t(M, s), M.prototype.elem = null, M.prototype.value = [20], M.prototype.maxValue = 80, M.prototype.minValue = 0, M.prototype.displayedAngle = 0, M.prototype.displayedValue = 0, M.prototype.lineWidth = 40, M.prototype.paddingTop = .1, M.prototype.paddingBottom = .1, M.prototype.percentColors = null, M.prototype.options = { colorStart: "#6fadcf", colorStop: void 0, gradientType: 0, strokeColor: "#e0e0e0", pointer: { length: .8, strokeWidth: .035, iconScale: 1 }, angle: .15, lineWidth: .44, radiusScale: 1, fontSize: 40, limitMax: !1, limitMin: !1 }, M.prototype.setOptions = function (t) { var i, e, s, n, o; for (null == t && (t = null), M.__super__.setOptions.call(this, t), this.configPercentColors(), this.extraPadding = 0, this.options.angle < 0 && (n = Math.PI * (1 + this.options.angle), this.extraPadding = Math.sin(n)), this.availableHeight = this.canvas.height * (1 - this.paddingTop - this.paddingBottom), this.lineWidth = this.availableHeight * this.options.lineWidth, this.radius = (this.availableHeight - this.lineWidth / 2) / (1 + this.extraPadding), this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), e = 0, s = (o = this.gp).length; e < s; e++)(i = o[e]).setOptions(this.options.pointer), i.render(); return this.render(), this }, M.prototype.configPercentColors = function () { var t, i, e, s, n, o, a; if (this.percentColors = null, void 0 !== this.options.percentColors) { for (this.percentColors = new Array, o = [], e = s = 0, n = this.options.percentColors.length - 1; 0 <= n ? s <= n : n <= s; e = 0 <= n ? ++s : --s)a = parseInt(l(this.options.percentColors[e][1]).substring(0, 2), 16), i = parseInt(l(this.options.percentColors[e][1]).substring(2, 4), 16), t = parseInt(l(this.options.percentColors[e][1]).substring(4, 6), 16), o.push(this.percentColors[e] = { pct: this.options.percentColors[e][0], color: { r: a, g: i, b: t } }); return o } }, M.prototype.set = function (t) { var i, e, s, n, o, a, h, r, l; for (t instanceof Array || (t = [t]), e = s = 0, h = t.length - 1; 0 <= h ? s <= h : h <= s; e = 0 <= h ? ++s : --s)t[e] = this.parseValue(t[e]); if (t.length > this.gp.length) for (e = n = 0, r = t.length - this.gp.length; 0 <= r ? n < r : r < n; e = 0 <= r ? ++n : --n)(i = new p(this)).setOptions(this.options.pointer), this.gp.push(i); else t.length < this.gp.length && (this.gp = this.gp.slice(this.gp.length - t.length)); for (a = e = 0, o = t.length; a < o; a++)(l = t[a]) > this.maxValue ? this.options.limitMax ? l = this.maxValue : this.maxValue = l + 1 : l < this.minValue && (this.options.limitMin ? l = this.minValue : this.minValue = l - 1), this.gp[e].value = l, this.gp[e++].setOptions({ minValue: this.minValue, maxValue: this.maxValue, angle: this.options.angle }); return this.value = Math.max(Math.min(t[t.length - 1], this.maxValue), this.minValue), AnimationUpdater.add(this), AnimationUpdater.run(this.forceUpdate), this.forceUpdate = !1 }, M.prototype.getAngle = function (t) { return (1 + this.options.angle) * Math.PI + (t - this.minValue) / (this.maxValue - this.minValue) * (1 - 2 * this.options.angle) * Math.PI }, M.prototype.getColorForPercentage = function (t, i) { var e, s, n, o, a, h, r; if (0 === t) e = this.percentColors[0].color; else for (e = this.percentColors[this.percentColors.length - 1].color, n = o = 0, h = this.percentColors.length - 1; 0 <= h ? o <= h : h <= o; n = 0 <= h ? ++o : --o)if (t <= this.percentColors[n].pct) { e = !0 === i ? (r = this.percentColors[n - 1] || this.percentColors[0], s = this.percentColors[n], a = (t - r.pct) / (s.pct - r.pct), { r: Math.floor(r.color.r * (1 - a) + s.color.r * a), g: Math.floor(r.color.g * (1 - a) + s.color.g * a), b: Math.floor(r.color.b * (1 - a) + s.color.b * a) }) : this.percentColors[n].color; break } return "rgb(" + [e.r, e.g, e.b].join(",") + ")" }, M.prototype.getColorForValue = function (t, i) { var e; return e = (t - this.minValue) / (this.maxValue - this.minValue), this.getColorForPercentage(e, i) }, M.prototype.renderStaticLabels = function (t, i, e, s) { var n, o, a, h, r, l, p, c, u, d; for (this.ctx.save(), this.ctx.translate(i, e), l = /\d+\.?\d?/, r = (n = t.font || "10px Times").match(l)[0], c = n.slice(r.length), o = parseFloat(r) * this.displayScale, this.ctx.font = o + c, this.ctx.fillStyle = t.color || "#000000", this.ctx.textBaseline = "bottom", this.ctx.textAlign = "center", a = 0, h = (p = t.labels).length; a < h; a++)void 0 !== (d = p[a]).label ? (!this.options.limitMin || d >= this.minValue) && (!this.options.limitMax || d <= this.maxValue) && (r = (n = d.font || t.font).match(l)[0], c = n.slice(r.length), o = parseFloat(r) * this.displayScale, this.ctx.font = o + c, u = this.getAngle(d.label) - 3 * Math.PI / 2, this.ctx.rotate(u), this.ctx.fillText(g(d.label, t.fractionDigits), 0, -s - this.lineWidth / 2), this.ctx.rotate(-u)) : (!this.options.limitMin || d >= this.minValue) && (!this.options.limitMax || d <= this.maxValue) && (u = this.getAngle(d) - 3 * Math.PI / 2, this.ctx.rotate(u), this.ctx.fillText(g(d, t.fractionDigits), 0, -s - this.lineWidth / 2), this.ctx.rotate(-u)); return this.ctx.restore() }, M.prototype.renderTicks = function (t, i, e, s) { var n, o, a, h, r, l, p, c, u, d, g, m, x, f, v, y, V, w, S, M; if (t !== {}) { for (l = t.divisions || 0, w = t.subDivisions || 0, a = t.divColor || "#fff", f = t.subColor || "#fff", h = t.divLength || .7, y = t.subLength || .2, u = parseFloat(this.maxValue) - parseFloat(this.minValue), d = parseFloat(u) / parseFloat(t.divisions), v = parseFloat(d) / parseFloat(t.subDivisions), n = parseFloat(this.minValue), o = 0 + v, r = (c = u / 400) * (t.divWidth || 1), V = c * (t.subWidth || 1), m = [], S = p = 0, g = l + 1; p < g; S = p += 1)this.ctx.lineWidth = this.lineWidth * h, x = this.lineWidth / 2 * (1 - h), M = this.radius * this.options.radiusScale + x, this.ctx.strokeStyle = a, this.ctx.beginPath(), this.ctx.arc(0, 0, M, this.getAngle(n - r), this.getAngle(n + r), !1), this.ctx.stroke(), o = n + v, n += d, S !== t.divisions && 0 < w ? m.push(function () { var t, i, e; for (e = [], t = 0, i = w - 1; t < i; t += 1)this.ctx.lineWidth = this.lineWidth * y, x = this.lineWidth / 2 * (1 - y), M = this.radius * this.options.radiusScale + x, this.ctx.strokeStyle = f, this.ctx.beginPath(), this.ctx.arc(0, 0, M, this.getAngle(o - V), this.getAngle(o + V), !1), this.ctx.stroke(), e.push(o += v); return e }.call(this)) : m.push(void 0); return m } }, M.prototype.render = function () { var t, i, e, s, n, o, a, h, r, l, p, c, u, d, g, m; if (g = this.canvas.width / 2, e = this.canvas.height * this.paddingTop + this.availableHeight - (this.radius + this.lineWidth / 2) * this.extraPadding, t = this.getAngle(this.displayedValue), this.textField && this.textField.render(this), this.ctx.lineCap = "butt", l = this.radius * this.options.radiusScale, this.options.staticLabels && this.renderStaticLabels(this.options.staticLabels, g, e, l), this.options.staticZones) for (this.ctx.save(), this.ctx.translate(g, e), this.ctx.lineWidth = this.lineWidth, s = 0, o = (p = this.options.staticZones).length; s < o; s++)r = (m = p[s]).min, this.options.limitMin && r < this.minValue && (r = this.minValue), h = m.max, this.options.limitMax && h > this.maxValue && (h = this.maxValue), d = this.radius * this.options.radiusScale, m.height && (this.ctx.lineWidth = this.lineWidth * m.height, u = this.lineWidth / 2 * (m.offset || 1 - m.height), d = this.radius * this.options.radiusScale + u), this.ctx.strokeStyle = m.strokeStyle, this.ctx.beginPath(), this.ctx.arc(0, 0, d, this.getAngle(r), this.getAngle(h), !1), this.ctx.stroke(); else void 0 !== this.options.customFillStyle ? i = this.options.customFillStyle(this) : null !== this.percentColors ? i = this.getColorForValue(this.displayedValue, this.options.generateGradient) : void 0 !== this.options.colorStop ? ((i = 0 === this.options.gradientType ? this.ctx.createRadialGradient(g, e, 9, g, e, 70) : this.ctx.createLinearGradient(0, 0, g, 0)).addColorStop(0, this.options.colorStart), i.addColorStop(1, this.options.colorStop)) : i = this.options.colorStart, this.ctx.strokeStyle = i, this.ctx.beginPath(), this.ctx.arc(g, e, l, (1 + this.options.angle) * Math.PI, t, !1), this.ctx.lineWidth = this.lineWidth, this.ctx.stroke(), this.ctx.strokeStyle = this.options.strokeColor, this.ctx.beginPath(), this.ctx.arc(g, e, l, t, (2 - this.options.angle) * Math.PI, !1), this.ctx.stroke(), this.ctx.save(), this.ctx.translate(g, e); for (this.options.renderTicks && this.renderTicks(this.options.renderTicks, g, e, l), this.ctx.restore(), this.ctx.translate(g, e), n = 0, a = (c = this.gp).length; n < a; n++)c[n].update(!0); return this.ctx.translate(-g, -e) }, o = M, t(C, s), C.prototype.lineWidth = 15, C.prototype.displayedValue = 0, C.prototype.value = 33, C.prototype.maxValue = 80, C.prototype.minValue = 0, C.prototype.options = { lineWidth: .1, colorStart: "#6f6ea0", colorStop: "#c0c0db", strokeColor: "#eeeeee", shadowColor: "#d5d5d5", angle: .35, radiusScale: 1 }, C.prototype.getAngle = function (t) { return (1 - this.options.angle) * Math.PI + (t - this.minValue) / (this.maxValue - this.minValue) * (2 + this.options.angle - (1 - this.options.angle)) * Math.PI }, C.prototype.setOptions = function (t) { return null == t && (t = null), C.__super__.setOptions.call(this, t), this.lineWidth = this.canvas.height * this.options.lineWidth, this.radius = this.options.radiusScale * (this.canvas.height / 2 - this.lineWidth / 2), this }, C.prototype.set = function (t) { return this.value = this.parseValue(t), this.value > this.maxValue ? this.options.limitMax ? this.value = this.maxValue : this.maxValue = this.value : this.value < this.minValue && (this.options.limitMin ? this.value = this.minValue : this.minValue = this.value), AnimationUpdater.add(this), AnimationUpdater.run(this.forceUpdate), this.forceUpdate = !1 }, C.prototype.render = function () { var t, i, e, s; return t = this.getAngle(this.displayedValue), s = this.canvas.width / 2, e = this.canvas.height / 2, this.textField && this.textField.render(this), (i = this.ctx.createRadialGradient(s, e, 39, s, e, 70)).addColorStop(0, this.options.colorStart), i.addColorStop(1, this.options.colorStop), this.radius, this.lineWidth, this.radius, this.lineWidth, this.ctx.strokeStyle = this.options.strokeColor, this.ctx.beginPath(), this.ctx.arc(s, e, this.radius, (1 - this.options.angle) * Math.PI, (2 + this.options.angle) * Math.PI, !1), this.ctx.lineWidth = this.lineWidth, this.ctx.lineCap = "round", this.ctx.stroke(), this.ctx.strokeStyle = i, this.ctx.beginPath(), this.ctx.arc(s, e, this.radius, (1 - this.options.angle) * Math.PI, t, !1), this.ctx.stroke() }, t(_, e = C), _.prototype.strokeGradient = function (t, i, e, s) { var n; return (n = this.ctx.createRadialGradient(t, i, e, t, i, s)).addColorStop(0, this.options.shadowColor), n.addColorStop(.12, this.options._orgStrokeColor), n.addColorStop(.88, this.options._orgStrokeColor), n.addColorStop(1, this.options.shadowColor), n }, _.prototype.setOptions = function (t) { var i, e, s, n; return null == t && (t = null), _.__super__.setOptions.call(this, t), n = this.canvas.width / 2, i = this.canvas.height / 2, e = this.radius - this.lineWidth / 2, s = this.radius + this.lineWidth / 2, this.options._orgStrokeColor = this.options.strokeColor, this.options.strokeColor = this.strokeGradient(n, i, e, s), this }, n = _, window.AnimationUpdater = { elements: [], animId: null, addAll: function (t) { var i, e, s, n; for (n = [], e = 0, s = t.length; e < s; e++)i = t[e], n.push(AnimationUpdater.elements.push(i)); return n }, add: function (t) { if (x.call(AnimationUpdater.elements, t) < 0) return AnimationUpdater.elements.push(t) }, run: function (t) { var i, e, s, n, o, a, h; if (null == t && (t = !1), isFinite(parseFloat(t)) || !0 === t) { for (i = !0, h = [], s = e = 0, o = (a = AnimationUpdater.elements).length; e < o; s = ++e)a[s].update(!0 === t) ? i = !1 : h.push(s); for (n = h.length - 1; 0 <= n; n += -1)s = h[n], AnimationUpdater.elements.splice(s, 1); return AnimationUpdater.animId = i ? null : requestAnimationFrame(AnimationUpdater.run) } if (!1 === t) return !0 === AnimationUpdater.animId && cancelAnimationFrame(AnimationUpdater.animId), AnimationUpdater.animId = requestAnimationFrame(AnimationUpdater.run) } }, "function" == typeof window.define && null != window.define.amd ? define(function () { return { Gauge: o, Donut: n, BaseDonut: e, TextRenderer: a } }) : "undefined" != typeof module && null != module.exports ? module.exports = { Gauge: o, Donut: n, BaseDonut: e, TextRenderer: a } : (window.Gauge = o, window.Donut = n, window.BaseDonut = e, window.TextRenderer = a) }).call(this);
</script>

<script>
  let verificarUsoDeDisco = true;
  let quantidadeDisco = 90;
  function disco() {
    quantidadeDisco = 0;
  }
  let opts_cpu = null;
  let opts_ram = null;
  function criarGraficos() {

    opts_cpu = {
      angle: 0, // ângulo inicial
      lineWidth: 0.22, // largura da linha
      radiusScale: 1, // escala do raio
      pointer: {
        length: 0.6, // comprimento do ponteiro
        strokeWidth: 0.035, // largura do ponteiro
        color: '#000000' // cor do ponteiro
      },
      limitMax: true, // se deve limitar o valor máximo
      limitMin: true, // se deve limitar o valor mínimo
      strokeColor: '#E0E0E0', // cor da linha
      generateGradient: true, // se deve gerar gradiente
      highDpiSupport: true, // suporte a alta definição
      staticZones: [
        { strokeStyle: "#30B32D", min: 0, max: criticoCpu }, // Zona verde
        { strokeStyle: "#FFDD00", min: criticoCpu, max: atencaoCpu }, // Zona amarela
        { strokeStyle: "#F03E3E", min: atencaoCpu, max: 10000 } // Zona vermelha
      ]
    };

    var target_cpu = document.getElementById('gauge-cpu');
    var gauge_cpu = new Gauge(target_cpu).setOptions(opts_cpu);

    gauge_cpu.maxValue = maximoCPU;
    gauge_cpu.setMinValue(0);
    gauge_cpu.animationSpeed = 5;

    // ----------------------------------------------------------------

    opts_ram = {
      angle: 0, // ângulo inicial
      lineWidth: 0.22, // largura da linha
      radiusScale: 1, // escala do raio
      pointer: {
        length: 0.6, // comprimento do ponteiro
        strokeWidth: 0.035, // largura do ponteiro
        color: '#000000' // cor do ponteiro
      },
      limitMax: true, // se deve limitar o valor máximo
      limitMin: true, // se deve limitar o valor mínimo
      strokeColor: '#E0E0E0', // cor da linha
      generateGradient: true, // se deve gerar gradiente
      highDpiSupport: true, // suporte a alta definição
      staticZones: [
        { strokeStyle: "#30B32D", min: 0, max: criticoRam }, // Zona verde
        { strokeStyle: "#FFDD00", min: criticoRam, max: atencaoRam }, // Zona amarela
        { strokeStyle: "#F03E3E", min: atencaoRam, max: 10000 } // Zona vermelha
      ]
    };

    var target_ram = document.getElementById('gauge-ram');
    var gauge_ram = new Gauge(target_ram).setOptions(opts_ram);

    gauge_ram.maxValue = maximoRAM;
    gauge_ram.setMinValue(0);
    gauge_ram.animationSpeed = 5;

    // ----------------------------------------------------------------

    // ----------------------------------------------------------------
  }
</script>



<script>
  let idFilial = sessionStorage.FILIAL;
  let numeroDeIdentificacao = sessionStorage.NUMERODEINDENTIFICACAO;

  idFilial = idFilial.replace(/\.|\-|\//g, '');
  let proximaAtualizacao;

  window.onload = obterDadosGraficos();

  function obterDadosGraficos() {
    obterDadosParametro(idFilial, numeroDeIdentificacao);
    obterDadosGrafico(idFilial, numeroDeIdentificacao);
    obterDadosGraficoReinicializacao(idFilial);
  }

  function obterDadosGrafico(idFilial, numeroDeIdentificacao) {
    // alterarTitulo(idFilial) essa variavel vai ter o nome da filial que ele está (ou as informações dela)
    fetch(`/medidas/ultimas/${idFilial}/${numeroDeIdentificacao}`, { cache: 'no-store' }).then(function (response) {
      if (response.ok) {
        response.json().then(function (resposta) {
          console.log(`Dados recebidos: ${JSON.stringify(resposta)}`);
          resposta.reverse();
          console.log(resposta)
          console.log('entrou no obter Dados Grafico1')

          plotarGrafico(resposta, idFilial, numeroDeIdentificacao);
        });
      } else {
        console.error('Nenhum dado encontrado ou erro na API');
        console.log('entrou no obter Dados Grafico2')


      }
    })
      .catch(function (error) {
        console.error(`Erro na obtenção dos dados p/ gráfico: ${error.message}`);
      });
  }
  let valorAtencao = null;
  let atencaoRam = null;
  let atencaoCpu = null;
  let valorCritico = null;
  let criticoRam = null;
  let criticoCpu = null;
  let moderadoRam = null;
  let moderadoCpu = null;

  function obterDadosParametro(idFilial, numeroDeIdentificacao) {
    // alterarTitulo(idFilial) essa variavel vai ter o nome da filial que ele está (ou as informações dela)
    fetch(`medidas/parametro/${idFilial}/${numeroDeIdentificacao}`, { cache: 'no-store' })
      .then(function (response) {
        if (response.ok) {
          response.json().then(function (resposta) {
            console.log(`Dados recebidos: ${JSON.stringify(resposta)}`);
            resposta.reverse();
            console.log(resposta);
            console.log('entrou no obter Dados Grafico1');

            // Filtra os valores para Atenção e Crítico
            atencaoRam = resposta[0].MemoriaRamLimite * 100;
            atencaoCpu = resposta[0].CPULimite * 100;
            criticoRam = resposta[1].MemoriaRamLimite * 100;
            criticoCpu = resposta[1].CPULimite * 100;
            moderadoRam = ((criticoRam * -1) - (atencaoRam * -1));
            moderadoCpu = ((criticoCpu * -1) - (atencaoCpu * -1));
            console.log(atencaoCpu + "asasa" + criticoCpu + "AQUIIIIIIIIIIIIIIIIIIIIIII");
            criarGraficos()

            console.log(atencaoRam + "OQUE TA VINDOOO")

          }

          );
        } else {
          console.error('Nenhum dado encontrado ou erro na API');
          console.log('entrou no obter Dados Grafico2');
        }
      })
      .catch(function (error) {
        console.error(`Erro na obtenção dos dados p/ gráfico: ${error.message}`);
      });
  }

  function cadastrarOcorrencia() {
    var inputData = document.getElementById("inputData").value;

    // Divida a data em dia, mês e ano
    var partesData = inputData.split("/"); // Supõe que a data está no formato "dd/mm/yyyy"

    // Obtenha os valores de dia, mês e ano
    var dia = partesData[0];
    var mes = partesData[1];
    var ano = partesData[2];

    // Crie a nova data no formato americano
    var dataAmericana = ano + "-" + mes + "-" + dia;
    var dadosInput = {
      titulo: inputTitulo.value,
      descricao: inputDescricao.value,
      dataDaOcorrencia: dataAmericana,
    }

    fetch(`/medidas/cadastrarOcorrencia/${numeroDeIdentificacao}/${idFilial}`, {
      method: "post",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(dadosInput)
    }).then(function (resposta) {

      console.log("resposta: ", resposta);

      if (resposta.ok) {
        closeModal2();
        console.log("DEU CERTOOO")
        window.location = "./telaDoGraficoTecnico.html"
      } else if (resposta.status == 404) {
        window.alert("Deu 404!");
      } else {
        throw ("Houve um erro ao tentar realizar a postagem! Código da resposta: " + resposta.status);
      }
    }).catch(function (resposta) {
      console.log(`#ERRO: ${resposta}`);
    });

    return false;

  }


  function obterDadosGraficoReinicializacao(idFilial) {
    fetch(`/medidas/ultimas/${idFilial}`, { cache: 'no-store' })
      .then(function (response) {
        if (response.ok) {
          if (response.status === 204) {
            // Nenhum conteúdo encontrado
            console.error('Nenhum dado encontrado');
            const dadosZerados = [
              { fkTotem: 'T1', Data: new Date().toISOString(), Total: 0 }
            ];
            plotarGraficoReinicializacao(dadosZerados, idFilial);
          } else {
            response.json()
              .then(function (resposta) {
                console.log(`Dados recebidos: ${JSON.stringify(resposta)}`);
                resposta.reverse();
                console.log(resposta);
                plotarGraficoReinicializacao(resposta, idFilial);
              })
              .catch(function (error) {
                console.error('Erro ao analisar a resposta JSON:', error);
              });
          }
        } else {
          console.error('Erro na resposta da API:', response.status);
        }
      })
      .catch(function (error) {
        console.error(`Erro na obtenção dos dados p/ gráfico: ${error.message}`);
      });
  }


  // Esta função *plotarGrafico* usa os dados capturados na função anterior para criar o gráfico
  // Configura o gráfico (cores, tipo, etc), materializa-o na página e, 
  // A função *plotarGrafico* também invoca a função *atualizarGrafico*



  function plotarGraficoReinicializacao(resposta, idFilial) {

    console.log('iniciando plotagem do gráfico...');

    console.log('----------------------------------------------')
    console.log('Estes dados foram recebidos pela funcao "obterDadosGrafico" e passados para "plotarGrafico":')
    console.log(resposta)

    console.log('----------------------------------------------');
    console.log('O gráfico será plotado com os respectivos valores:')
    console.log('----------------------------------------------');


    setTimeout(() => atualizarGraficoReinicializacoes(resposta, idFilial), 2000);
  }


  // Função para gerar o PDF
  function GerarPDF() {
    const element = document.createElement('div');

    // Definindo o conteúdo HTML com o texto desejado
    element.innerHTML = `
    <!DOCTYPE html>
    <html>
    <head>

      <style>
  
        body {
          font-family: Arial, sans-serif;
          background-color: #f2f2f2;
          padding: 20px;
        }
        
        .container {
          max-width: 600px;
          margin: 0 auto;
          background-color: #ffffff;
          padding: 20px;
          border-radius: 5px;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
          font-size: 24px;
          color: #333333;
        }
        
        p {
          font-size: 16px;
          color: #555555;
          line-height: 1.5;
        }
        
        .warning {
          color: #ff0000;
          font-weight: bold;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <h1>Atenção: Uso de disco em nível crítico</h1>
        <p>
          Prezado usuário,<br>
          Gostaríamos de informar que o totem ${numeroDeIdentificacao} que você está utilizando chegou a 90% de uso no disco. É importante tomar medidas para liberar espaço e evitar problemas futuros. O espaço em disco é essencial para o funcionamento adequado do totem e armazenamento de dados importantes.
        </p>
        <p class="warning">Recomendamos que você libere espaço no disco o mais rápido possível para evitar possíveis travamentos e erros no sistema.</p>
        <p>
          Seguem algumas orientações para liberar espaço no disco:
          <ul>
            <li>Remova arquivos desnecessários;</li>
            <li>Desinstale aplicativos não utilizados;</li>
            <li>Limpe a lixeira do sistema;</li>
            <li>Mova arquivos grandes para um dispositivo de armazenamento externo;</li>
            <li>Utilize ferramentas de limpeza de disco.</li>
          </ul>
        </p>
        <p>
          Ao liberar espaço no disco, você garantirá um melhor desempenho e evitará problemas futuros relacionados ao armazenamento. Caso tenha alguma dúvida ou precise de suporte adicional, não hesite em entrar em contato conosco.
        </p>
        <p>
          Agradecemos sua atenção e colaboração na manutenção adequada do totem.
        </p>
        <p>
          Atenciosamente,<br>
          Infinity Solutions
        </p>
      </div>
    </body>
    </html>
  `;
    const hoje = new Date();
    const dataFormatada = hoje.toLocaleDateString('pt-BR').replaceAll('/', '-');

    html2pdf().from(element).save(`Relatório de Disco Dia - ${dataFormatada}.pdf`);
  }
  let dataAntiga = "";

  function GerarPDF2() {
    const element = document.createElement('div');
    fetch(`/medidas/gerarPDF/${idFilial}`).then(function (resposta) {
      if (resposta.ok) {
        if (resposta.status == 204) {
          throw "Nenhum resultado encontrado!!";
        }
        resposta.json().then(function (dadosAPI) {
          console.log("Dados recebidos: ", JSON.stringify(dadosAPI));

          // Criar a tabela com os dados da API
          let tableHTML = '<table>';
          tableHTML += '<div class="Header">';
          tableHTML += '<thead><tr>';
          const headers = ["CNPJ da Empresa", "Totem", "Uso de Memória RAM", "Uso de CPU", "Data e Hora da Reinicialização"];
          headers.forEach(headerText => {
            tableHTML += `<th>${headerText}</th>`;
          });
          tableHTML += '</tr></thead></div>';

          tableHTML += '<tbody>';
          dadosAPI.forEach(dado => {
            tableHTML += '<div class="corpo"><tr>';
            const values = [dado.MonitoramentoDeRecursos_fkEmpresa, dado.MonitoramentoDeRecursos_FkNumIdenti, dado.UsoDeMemoriaRam.toFixed(2), dado.UsoDeCPU.toFixed(2), formatarDataHora(dado.DataHora)];
            values.forEach(valueText => {
              if (dataAntiga != valueText)
                tableHTML += `<td>${valueText}</td>`;
            });
            tableHTML += '</tr></div>';

            // Adicionar linha entre as colunas
            tableHTML += '<tr class="spacer-row"><td colspan="' + values.length + '"></td></tr>';
          });
          tableHTML += '</tbody></table>';

          // Definir o conteúdo HTML com o texto desejado
          const hoje = new Date();
          const dataFormatada = hoje.toLocaleDateString('pt-BR').replaceAll('/', '-');
          element.innerHTML = `
          ${tableHTML}
          <div class="teste">
          <h1>Aviso de Reinicializações do Totem</h1>
          <p>Prezado usuário,</p>
          <p>O totem foi reiniciado várias vezes devido ao alto uso crítico de recursos. A seguir estão as últimas reinicializações registradas:</p>
          <p>Por favor, tome as medidas necessárias para evitar o alto uso crítico de recursos e a reinicialização frequente do totem.</p>
          <p>Obrigado pela sua compreensão e colaboração.</p>
          <div>
        `;

          // Estilos personalizados
          const style = `
          <style>
            table {
              width: 100%;
              border-collapse: collapse;
            }

            th, td {
              padding: 8px;
              text-align: center;
              
            }
            td{
              border: 0.5px solid black;
            }
            tr{
               align-items: center;
              border:1px solid black;
            }
            .thead{
            align-items: center;
               display: flex;
              border:1px solid black;
            }
            th {
              font-weight: bold;
              background-color: #f2f2f2;
              text-align: center;

            }
            .corpo{
  align-items: center;
  display: flex;
            }
            .teste{
              display: flex;
    flex-direction: column;
    font-size: 20px;
            }
          </style>
        `;
          element.innerHTML += style;

          // Criar e salvar o PDF
          html2pdf().from(element).save(`Relatório de reinicialização Dia - ${dataFormatada}.pdf`);
        });
      } else {
        throw ('Houve um erro na API!');
      }
    }).catch(function (resposta) {
      console.error(resposta);
    });
  }
  function formatarDataHora(dataHora) {
    const data = new Date(dataHora);
    const dia = String(data.getDate()).padStart(2, '0');
    const mes = String(data.getMonth() + 1).padStart(2, '0');
    const hora = String(data.getHours()).padStart(2, '0');
    const minutos = String(data.getMinutes()).padStart(2, '0');
    return `${dia}/${mes} ${hora}:${minutos}`;
  }

  function GerarPDF3() {
  let element = `
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="UTF-8">
      <title>Relatório de Incidentes</title>
      <style>
        body {
          font-family: Arial, sans-serif;
          margin: 20px;
        }
        
        h1 {
          text-align: center;
          margin-bottom: 20px;
        }
        
        table {
          width: 100%;
          border-collapse: collapse;
        }
        
        th, td {
          padding: 8px;
          border: 1px solid #ccc;
        }
        
        th {
          background-color: #f2f2f2;
        }
      </style>
    </head>
    <body>
      <h1>Relatório de Incidentes</h1>
    `;

  fetch(`/medidas/listarocorrencia2/${idFilial}`).then(function (resposta) {
    if (resposta.ok) {
      if (resposta.status == 204) {
        throw "Nenhum resultado encontrado!!";
      }
      resposta.json().then(function (resposta) {
        console.log("Dados recebidos: ", JSON.stringify(resposta));
        element += `
          <table>          
            <thead>
              <tr>
                <th>Título do Incidente</th>
                <th>Data</th>
                <th>Descrição</th>
                <th>Totem</th>
              </tr>
            </thead>
            <tbody id='relatorio'>
        `;
        resposta.forEach(dado => {
          element += `
            <tr>
              <td>${dado.titulo}</td>
              <td>${formatarData2(dado.dataDaOcorencia)}</td>
              <td>${dado.descricao}</td>
              <td>${dado.fkTotem}</td>
            </tr>
          `;
        });
        element += `
            </tbody>
          </table>
        </body>
        </html>
        `;
        const hoje = new Date();
        const dataFormatada = hoje.toLocaleDateString('pt-BR').replaceAll('/', '-');
        html2pdf().from(element).save(`Relatório de Incidentes Dia - ${dataFormatada}.pdf`);
      });
    } else {
      throw ('Houve um erro na API!');
    }
  }).catch(function (resposta) {
    console.error(resposta);
  });
}

function formatarData2(data) {
  const dataObj = new Date(data);
  const dia = String(dataObj.getDate()).padStart(2, '0');
  const mes = String(dataObj.getMonth() + 1).padStart(2, '0');
  const ano = dataObj.getFullYear();
  return `${dia}/${mes}/${ano}`;
}

  // Definindo o conteúdo HTML com o texto desejado



  let verificarReiniciar = true

  function adicionarDataset(label, data, color) {
    chart.data.datasets.push({
      label: label,
      data: data,
      borderColor: color,
      backgroundColor: color
    });
  }

  let jsonAntigo = 0;
  function limparDadosGrafico() {
    chart.data.datasets.forEach(dataset => {
      dataset.data = []; // Limpar os dados do dataset
      // Mantenha a cor de fundo original para evitar repetição
    });
  }

  let quantidadeDeReinicializacoesHoje = 0;
  function atualizarGraficoReinicializacoes(resposta, idFilial) {
    limparDadosGrafico(); // Limpar completamente os dados do gráfico antes de adicionar os novos dados

    const diasMes = 31; // Supondo que estamos considerando um mês com 31 dias

    // Criar um objeto para armazenar os dados por fkTotem
    const dadosPorTotem = {};

    // Inicializar o objeto com arrays vazios para cada fkTotem
    for (posicaoAtual = 0; posicaoAtual < resposta.length; posicaoAtual++) {
      fkTotem = resposta[posicaoAtual].fkTotem;
      dadosPorTotem[fkTotem] = {};
    }

    // Adicionar os dados existentes à estrutura de dados por fkTotem
    for (posicaoAtual = 0; posicaoAtual < resposta.length; posicaoAtual++) {
      const dataHora = new Date(resposta[posicaoAtual].Data);
      dataHora.setUTCHours(0, 0, 0, 0); // Definir a hora como 0 em UTC
      const qtdReinicializacoes = resposta[posicaoAtual].Total;
      fkTotem = resposta[posicaoAtual].fkTotem;
      const dia = dataHora.getUTCDate(); // Obter o dia em UTC
      if (dadosPorTotem[fkTotem][dia] === undefined) {
        dadosPorTotem[fkTotem][dia] = qtdReinicializacoes;
      } else {
        dadosPorTotem[fkTotem][dia] += qtdReinicializacoes;
      }
    }

    // Criar arrays de dados por dia para cada fkTotem
    const dadosTotemPorDia = {};
    for (fkTotem in dadosPorTotem) {
      dadosTotemPorDia[fkTotem] = [];
      for (dia = 1; dia <= diasMes; dia++) {
        const qtdReinicializacoes = dadosPorTotem[fkTotem][dia] || 0;
        dadosTotemPorDia[fkTotem].push(qtdReinicializacoes);
      }
    }
    const hoje = getCurrentDate();

    // Percorrer os objetos no array da resposta JSON
    for (let i = 0; i < resposta.length; i++) {
      const objeto = resposta[i];
      const data = objeto.Data.substr(0, 10); // Extrair a parte da data "yyyy-mm-dd"

      // Verificar se a data corresponde ao dia de hoje
      if (data === hoje) {
        quantidadeDeReinicializacoesHoje = objeto.Total;
        if (verificarReiniciar) {
          verificarReiniciar = false;
          quantidadeDeChamados++;
          chamadosAberto.innerHTML = `${quantidadeDeChamados} chamados em aberto`
        }
      }
    }

    // Atualize as labels do gráfico
    const labels = Array.from({ length: diasMes }, (_, i) => (i + 1).toString().padStart(2, '0'));
    chart.data.labels = labels;

    // Atualize o dataset correspondente ao fkTotem ou adicione um novo dataset
    for (fkTotem in dadosTotemPorDia) {
      const dadosTotem = dadosTotemPorDia[fkTotem];

      const datasetIndex = chart.data.datasets.findIndex(dataset => dataset.label === fkTotem);
      if (datasetIndex !== -1) {
        chart.data.datasets[datasetIndex].data = dadosTotem;
      } else {
        const randomColor = getRandomColor();
        adicionarDataset(fkTotem, dadosTotem, randomColor);
      }
    }

    // Atualize o gráfico após adicionar todos os novos dados
    chart.update();
    proximaAtualizacao = setTimeout(() => obterDadosGraficoReinicializacao(idFilial), 2000);
  }


  function getYesterdayDate() {
    const currentDate = new Date();
    const yesterday = new Date(currentDate);
    yesterday.setDate(currentDate.getDate() - 1);
    const year = yesterday.getFullYear();
    const month = String(yesterday.getMonth() + 1).padStart(2, '0');
    const day = String(yesterday.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }
  function plotarGrafico(resposta, idFilial, numeroDeIdentificacao) {

    console.log('iniciando plotagem do gráfico...');

    console.log('----------------------------------------------')
    console.log('Estes dados foram recebidos pela funcao "obterDadosGrafico" e passados para "plotarGrafico":')
    console.log(resposta)


    console.log('----------------------------------------------')
    console.log('O gráfico será plotado com os respectivos valores:')
    console.log('----------------------------------------------')



    setTimeout(() => atualizarGrafico(idFilial, numeroDeIdentificacao), 2000);
  }
  let quantidadeDeChamados = 0;
  function atualizarGrafico(idFilial, numeroDeIdentificacao) {
    fetch(`/medidas/tempo-real/${idFilial}/${numeroDeIdentificacao}`, { cache: 'no-store' }).then(function (response) {
      if (response.ok) {
        response.json().then(function (novoRegistro) {

          console.log(`Dados recebidos: ${JSON.stringify(novoRegistro)}`);
          console.log(`Dados atuais do gráfico:`);


          // Verificar o valor do gauge ram e definir a cor do innerHTML correspondente
          const valorRam = novoRegistro[0].UsoDeMemoriaRam * 100;
          if (valorRam >= atencaoRam) {
            tituloRam.style.color = "red";
          } else if (valorRam >= criticoRam) {
            tituloRam.style.color = "orange";
          } else {
            tituloRam.style.color = "green";
          }

          // Verificar o valor do gauge CPU e definir a cor do innerHTML correspondente
          const valorCPU = novoRegistro[0].UsoDeCPU * 100;
          if (valorCPU >= atencaoCpu) {
            tituloCPU.style.color = "red";
          } else if (valorCPU >= criticoCpu) {
            tituloCPU.style.color = "orange";
          } else {
            tituloCPU.style.color = "green";
          }
          // ---------------------------------- atualizar gauge ram  ----------------------------------

          var target_ram = document.getElementById('gauge-ram');
          var gauge_ram = new Gauge(target_ram).setOptions(opts_ram);
          console.log("GAUGE RAM " + novoRegistro[0])
          gauge_ram.setMinValue(0);
          gauge_ram.animationSpeed = 5;
          gauge_ram.maxValue = 10000;
          gauge_ram.set((novoRegistro[0].UsoDeMemoriaRam * 100));
          console.log("AQUI TA VENDO O USO ATUAL DA RAMMMMMMMMMMMMMMMM");
          console.log(novoRegistro[0].UsoDeMemoriaRam * 100);
          tituloRam.innerHTML = `${(novoRegistro[0].UsoDeMemoriaRam).toFixed(2)}%`
          // ---------------------------------- atualizar gauge CPU ----------------------------------

          var target_cpu = document.getElementById('gauge-cpu');
          var gauge_cpu = new Gauge(target_cpu).setOptions(opts_cpu);
          gauge_cpu.maxValue = maximoCPU;
          gauge_cpu.setMinValue(0);
          gauge_cpu.animationSpeed = 5;
          gauge_cpu.set((novoRegistro[0].UsoDeCPU * 100));
          tituloCPU.innerHTML = `${(novoRegistro[0].UsoDeCPU).toFixed(2)}%`

          // ------------------------  atualizar gauge temperatura da CPU --------------------------
          const textoOriginal = novoRegistro[0].vidaUtil;
          const novoTexto = converterTexto(textoOriginal);
          tituloVidaUtil.innerHTML = novoTexto
          console.log(novoTexto);

          if (verificarUsoDeDisco) {
            if (novoRegistro[0].UsoDeDisco >= quantidadeDisco) {
              verificarUsoDeDisco = false;
              quantidadeDeChamados++
              chamadosAberto.innerHTML = `${quantidadeDeChamados} chamados em aberto`
            }
          } else {
            if (novoRegistro[0].UsoDeDisco <= 90) {
              verificarUsoDeDisco = true;
              quantidadeDeChamados--;
              chamadosAberto.innerHTML = `${quantidadeDeChamados} chamados em aberto`
            }
          }

          fetch(`/medidas/listarocorrencia/${idFilial}`).then(function (resposta) {
            if (resposta.ok) {
              if (resposta.status == 204) {
                throw "Nenhum resultado encontrado!!";
              }
              resposta.json().then(function (teste) {
                console.log("Dados recebidos: ", JSON.stringify(teste));
                if (verificarIncidentes) {

                  if (teste[0].TotalRows >= 1) {
                    quantidadeDeChamados++
                    chamadosAberto.innerHTML = `${quantidadeDeChamados} chamados em aberto`
                    verificarIncidentes = false;
                  }
                }

              });
            } else {
              throw ('Houve um erro na API!');
            }
          }).catch(function (resposta) {
            console.error(resposta);
          });

          // Altere aqui o valor em ms se quiser que o gráfico atualize mais rápido ou mais devagar
          proximaAtualizacao = setTimeout(() => atualizarGrafico(idFilial, numeroDeIdentificacao), 2000);
        });
      } else {
        console.error('Nenhum dado encontrado ou erro na API');
        // Altere aqui o valor em ms se quiser que o gráfico atualize mais rápido ou mais devagar
        proximaAtualizacao = setTimeout(() => atualizarGrafico(idFilial, numeroDeIdentificacao), 2000);
      }
    })
      .catch(function (error) {
        console.error(`Erro na obtenção dos dados p/ gráfico: ${error.message}`);
      });

  }

  let verificarIncidentes = true;
  function openModal3() {
    bodyModal.innerHTML = ''
    if (quantidadeDeReinicializacoesHoje > 5) {

      bodyModal.innerHTML += `
      <div class="chamado2" id="chamado2">
            Abrir relatorio sobre Reinicizalizações
            <div class="relatorio" onclick="GerarPDF2()">
              <i class="uil uil-file-info-alt"></i>
            </div>
        </div>
      `
    }

    // Verificar se o disco está acima de 90%
    if (!verificarUsoDeDisco) {
      bodyModal.innerHTML += `
    <div class="chamado1" id="chamado1">
              Abrir relatorio sobre Disco 
              <div class="relatorio" onclick="GerarPDF()">
                <i class="uil uil-file-info-alt"></i>
              </div>
          </div>
    `
    }

    // Verificar se não existem chamados abertos e o disco está abaixo de 90%
    if (quantidadeDeReinicializacoesHoje === 0 && verificarUsoDeDisco && verificarIncidentes) {
      bodyModal.innerHTML = `
    <div class="sumir0" id="chamado0">
            Você não possui nenhum chamado
          </div>  
    `
    }

    if (!verificarIncidentes) {

      bodyModal.innerHTML += `
<div class="chamado2" id="chamado2">

Abrir relatorio sobre Incidentes
<div class="relatorio" onclick="GerarPDF3()">
<i class="uil uil-file-info-alt"></i>
</div>
</div>
`

    }






    const modal3 = document.querySelector('#my-modal3');
    modal3.style.display = 'block';

  }
  function getCurrentDate() {
    const currentDate = new Date();
    const year = currentDate.getFullYear();
    const month = String(currentDate.getMonth() + 1).padStart(2, '0');
    const day = String(currentDate.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }

  // Close
  function closeModal3() {
    const modal3 = document.querySelector('#my-modal3');

    modal3.style.display = 'none';
  }
  // Função para gerar uma cor aleatória
  function getRandomColor() {
    const letters = '0123456789ABCDEF';
    let color = '#';
    for (let i = 0; i < 6; i++) {
      color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
  }

  function converterTexto(texto) {
    // Dividir o texto em dias, horas, minutos e segundos
    const partes = texto.split(', ');

    // Obter o número de dias
    const dias = partes[0].split(' ')[0];

    // Obter o número de horas, minutos e segundos
    const tempo = partes[1].split(':');
    const horas = parseInt(tempo[0]);
    const minutos = parseInt(tempo[1]);

    // Criar o novo texto
    const novoTexto = dias + ' dias ' + horas + ' horas e ' + minutos + ' minutos';

    return novoTexto;
  }



</script>